"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduledTaskHandler = void 0;
const framework_1 = require("@sapphire/framework");
const stopwatch_1 = require("@sapphire/stopwatch");
const ScheduledTaskRedisStrategy_1 = require("./strategies/ScheduledTaskRedisStrategy");
const ScheduledTaskEvents_1 = require("./types/ScheduledTaskEvents");
class ScheduledTaskHandler {
    constructor(options) {
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.strategy = options?.strategy ?? new ScheduledTaskRedisStrategy_1.ScheduledTaskRedisStrategy();
        this.strategy.connect();
    }
    get client() {
        return this.strategy.client;
    }
    create(task, payload, options) {
        if (typeof options === 'number') {
            options = {
                type: 'default',
                delay: options
            };
        }
        return this.strategy.create(task, payload, options);
    }
    createRepeated() {
        const { store } = this;
        return this.strategy.createRepeated(store.repeatedTasks.map((piece) => ({
            name: piece.name,
            options: {
                type: 'repeated',
                ...(piece.interval
                    ? {
                        interval: piece.interval,
                        bullJobOptions: piece.bullJobOptions
                    }
                    : {
                        cron: piece.cron,
                        bullJobOptions: piece.bullJobOptions
                    })
            }
        })));
    }
    delete(id) {
        return this.strategy.delete(id);
    }
    list(options) {
        return this.strategy.list(options);
    }
    listRepeated(options) {
        return this.strategy.listRepeated(options);
    }
    get(id) {
        return this.strategy.get(id);
    }
    async run(task, payload) {
        const piece = this.store.get(task);
        if (!piece) {
            framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskNotFound, task, payload);
            return;
        }
        const result = await (0, framework_1.fromAsync)(async () => {
            framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskRun, task, payload);
            const stopwatch = new stopwatch_1.Stopwatch();
            const taskRunResult = await piece.run(payload);
            const { duration } = stopwatch.stop();
            framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskSuccess, task, payload, taskRunResult, duration);
            return duration;
        });
        if ((0, framework_1.isErr)(result)) {
            framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskError, result.error, task, payload);
        }
        framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskFinished, task, result.value, payload);
        return result.value;
    }
    get store() {
        return framework_1.container.client.stores.get('scheduled-tasks');
    }
}
exports.ScheduledTaskHandler = ScheduledTaskHandler;
//# sourceMappingURL=ScheduledTaskHandler.js.map
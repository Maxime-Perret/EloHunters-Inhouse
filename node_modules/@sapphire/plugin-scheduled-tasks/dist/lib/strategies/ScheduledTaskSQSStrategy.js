"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduledTaskSQSStrategy = void 0;
const framework_1 = require("@sapphire/framework");
const crypto_1 = require("crypto");
const sqs_consumer_1 = require("sqs-consumer");
const sqs_producer_1 = require("sqs-producer");
const ScheduledTaskEvents_1 = require("../types/ScheduledTaskEvents");
class ScheduledTaskSQSStrategy {
    constructor(options) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "producer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.options = options;
        this.producer = sqs_producer_1.Producer.create(this.options);
    }
    get client() {
        return this.producer;
    }
    connect() {
        const connectResult = (0, framework_1.from)(() => {
            const consumer = sqs_consumer_1.Consumer.create({
                ...this.options,
                handleMessage: this.handleMessage.bind(this),
                handleMessageBatch: this.handleBatch.bind(this)
            });
            consumer.start();
        });
        if ((0, framework_1.isErr)(connectResult)) {
            framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskStrategyConnectError, connectResult.error);
        }
    }
    create(task, payload, options) {
        if (options?.cron) {
            throw new Error('SQS does not support cron notation.');
        }
        let delay = (options?.delay ?? 0) / 1000;
        if (options?.type === 'repeated') {
            delay = options.interval / 1000;
        }
        return this.producer.send({
            id: `${task}-${(0, crypto_1.randomBytes)(6)}`,
            body: JSON.stringify({
                task,
                payload,
                options
            }),
            delaySeconds: delay
        });
    }
    async createRepeated(tasks) {
        for (const task of tasks) {
            await this.create(task.name, null, task.options);
        }
    }
    delete() {
        throw new Error('SQS does not support deleting tasks.');
    }
    list() {
        throw new Error('SQS does not support listing tasks.');
    }
    listRepeated() {
        throw new Error('SQS does not support listing tasks.');
    }
    get() {
        throw new Error('SQS does not support getting tasks.');
    }
    run(task, payload) {
        return framework_1.container.tasks.run(task, payload);
    }
    async handleMessage(message) {
        const data = JSON.parse(message.Body);
        await this.run(data.task, data.payload);
        if (data.options.type === 'repeated') {
            await this.create(data.task, data.payload, data.options);
        }
    }
    async handleBatch(messages) {
        for (const message of messages) {
            await this.handleMessage(message);
        }
    }
}
exports.ScheduledTaskSQSStrategy = ScheduledTaskSQSStrategy;
//# sourceMappingURL=ScheduledTaskSQSStrategy.js.map
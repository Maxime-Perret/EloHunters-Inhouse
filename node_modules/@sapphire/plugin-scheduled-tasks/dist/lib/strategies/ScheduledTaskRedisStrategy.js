"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduledTaskRedisStrategy = void 0;
const tslib_1 = require("tslib");
const framework_1 = require("@sapphire/framework");
const bull_1 = tslib_1.__importDefault(require("bull"));
const ScheduledTaskEvents_1 = require("../types/ScheduledTaskEvents");
class ScheduledTaskRedisStrategy {
    constructor(options) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bullClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.queue = options?.queue ?? 'scheduled-tasks';
        this.options = options?.bull ?? {};
    }
    get client() {
        return this.bullClient;
    }
    connect() {
        const connectResult = (0, framework_1.from)(() => {
            this.bullClient = new bull_1.default(this.queue, this.options);
            void this.bullClient.process('*', (job) => this.run(job?.name, job?.data));
        });
        if ((0, framework_1.isErr)(connectResult)) {
            framework_1.container.client.emit(ScheduledTaskEvents_1.ScheduledTaskEvents.ScheduledTaskStrategyConnectError, connectResult.error);
        }
    }
    create(task, payload, options) {
        if (!this.bullClient) {
            return;
        }
        let bullOptions = {
            delay: options?.delay,
            ...options?.bullJobOptions
        };
        if (options?.type === 'repeated') {
            bullOptions = {
                ...bullOptions,
                repeat: options?.interval
                    ? {
                        every: options.interval
                    }
                    : {
                        cron: options.cron
                    }
            };
        }
        return this.bullClient.add(task, payload ?? null, bullOptions);
    }
    async createRepeated(tasks) {
        for (const task of tasks) {
            await this.create(task.name, null, task.options);
        }
    }
    async delete(id) {
        if (!this.bullClient) {
            return;
        }
        const job = await this.get(id);
        return job?.remove();
    }
    list(options) {
        const { types, start, end, asc } = options;
        if (!this.bullClient) {
            return;
        }
        return this.bullClient.getJobs(types, start, end, asc);
    }
    listRepeated(options) {
        const { start, end, asc } = options;
        if (!this.bullClient) {
            return;
        }
        return this.bullClient.getRepeatableJobs(start, end, asc);
    }
    get(id) {
        if (!this.bullClient) {
            return;
        }
        return this.bullClient.getJob(id);
    }
    run(task, payload) {
        return framework_1.container.tasks.run(task, payload);
    }
}
exports.ScheduledTaskRedisStrategy = ScheduledTaskRedisStrategy;
//# sourceMappingURL=ScheduledTaskRedisStrategy.js.map